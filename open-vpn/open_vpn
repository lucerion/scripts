#!/usr/bin/env ruby

require 'optparse'
require 'yaml'

DEFAULT_OPTIONS = {
  config: File.expand_path('~/.config/open_vpn.yml'),
  bin: File.expand_path('/usr/sbi_filen/openvpn')
}.freeze

COMMANDS = {
  start: 'start',
  stop: 'stop',
  restart: 'restart',
  status: 'status'
}.freeze

START_COMMAND = 'sudo %<bin>s --config %<config>s --writepid %<pid_file>s --daemon'.freeze
PID_FILE = '/var/run/open_vpn%<postfix>s.pid'.freeze

MESSAGES = {
  no_binary: 'Binary "%s" not found or not executable!',
  no_config: 'Config "%s" not found!',
  no_destination_config: 'Config "%<config>s" for destination "%<destination>s" not found!',
  running: 'OpenVPN is running',
  not_running: 'OpenVPN is not running'
}.freeze

def options_parser(options)
  OptionParser.new('Usage: open_vpn {start|stop|restart|status} DESTINATION [OPTIONS]') do |option|
    option.on('-c', '--config FILE', "config file. Default: #{DEFAULT_OPTIONS[:config]}") do |value|
      options[:config] = File.expand_path(value)
    end
    option.on('--bin FILE', "executable file. Default: #{DEFAULT_OPTIONS[:bin]}") do |value|
      options[:bin] = File.expand_path(value)
    end
    option.on_tail('--help', 'display a usage message') do
      puts option
      exit
    end
  end
end

def parse_options!(args = ARGV)
  command, destination = args.reject { |arg| arg.start_with?('-') }

  DEFAULT_OPTIONS.dup.tap do |options|
    options_parser(options).parse!(args)

    options[:command] = command
    options[:destination] = destination
  end
end

def error(type, options)
  raise format(MESSAGES[type], options)
end

def bin(options)
  options.fetch(:bin).tap do |bin|
    error(:binary_not_found, bin) unless File.executable?(bin)
  end
end

def config(options)
  destination = options.fetch(:destination)
  return destination if destination_option_config?(destination)

  config_file = options.fetch(:config)
  error(:no_config, config_file) unless File.exist?(config_file)

  (YAML.load_file(config_file) || {}).fetch(destination, '').tap do |config|
    error(:no_destination_config, config: config, destination: destination) unless File.exist?(config)
  end
end

def destination_option_config?(destination)
  File.exist?(destination)
end

def pid_file(options)
  destination = options.fetch(:destination)
  postfix = destination_option_config?(destination) ? '' : ".#{destination}"
  format(PID_FILE, postfix: postfix)
end

def pid(pid_file)
  return unless File.exist?(pid_file)

  pid = File.read(pid_file).strip
  pid.to_i unless pid.empty?
end

def runned?(pid)
  return false unless pid

  Process.getpgid(pid)
  true
rescue Errno::ESRCH
  false
end

def start(options)
  exec format(START_COMMAND, bin: bin(options), config: config(options), pid_file: pid_file(options))
end

def stop(options)
  pid_file = pid_file(options)
  pid = pid(pid_file)

  return unless runned?(pid)

  `sudo kill #{pid}`
  `sudo rm #{pid_file}`
end

def restart(options)
  stop(options)
  start(options)
end

def status(options)
  pid = pid(pid_file(options))
  puts runned?(pid) ? MESSAGES[:running] : MESSAGES[:not_running]
end

def help
  parse_options!(%w[--help])
end

options = parse_options!
command = options[:command]
COMMANDS.value?(command) ? send(command, options) : help
