#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'yaml'

DEFAULT_OPTIONS = {
  config: File.expand_path('~/.config/open_vpn.yml'),
  bin: File.expand_path('/usr/sbin/openvpn')
}.freeze

COMMANDS = %w[start stop restart status].freeze

START_COMMAND = 'sudo %<bin>s --config %<vpn_config>s --writepid %<pid_file>s --daemon'
PID_FILE = '/var/run/open_vpn%<postfix>s.pid'

ERRORS = {
  no_binary: 'Binary "%s" not found or not executable!',
  no_config: 'Config "%s" not found!'
}.freeze

MESSAGES = {
  running: 'OpenVPN is running',
  not_running: 'OpenVPN is not running'
}.freeze

def options_parser(options = {})
  OptionParser.new('Usage: open_vpn start|stop|restart|status DESTINATION [OPTION]') do |option|
    option.on('-c', '--config FILE', "config file. Default: #{DEFAULT_OPTIONS[:config]}") do |config_path|
      options[:config] = File.expand_path(config_path)
    end
    option.on('--bin FILE', "executable file. Default: #{DEFAULT_OPTIONS[:bin]}") do |bin_path|
      options[:bin] = File.expand_path(bin_path)
    end
    option.on_tail('--help', 'display a usage message') do
      puts option
      exit
    end
  end
end

def help
  options_parser.parse(%w[--help])
end

def error(type, option)
  raise format(ERRORS[type], option)
end

def parse_options!(args = ARGV)
  command, destination = args.reject { |arg| arg.start_with?('-') }

  DEFAULT_OPTIONS.dup.tap do |options|
    options_parser(options).parse!(args)
    options.merge!(command: command, destination: destination)
  end
end

def validate_options!(options)
  command = options[:command]
  help unless command && options[:destination] && COMMANDS.include?(command)

  bin = options[:bin]
  error(:no_binary, bin) unless File.executable?(bin)
end

def parse_config(options)
  options.tap do |config|
    config[:vpn_config] = vpn_config(options)
  end
end

def vpn_config(options)
  destination = options[:destination]
  destination_path = File.expand_path(destination)
  return destination_path if File.exist?(destination_path)

  config_path = File.expand_path(options[:config])
  return unless File.exist?(config_path)

  config = YAML.load_file(config_path)
  vpn_config = config[destination]
  vpn_config_path = File.expand_path(vpn_config) if vpn_config
  return vpn_config_path if vpn_config_path && File.exist?(vpn_config_path)
end

def validate_config!(config)
  vpn_config = config[:vpn_config]
  error(:no_config, vpn_config) unless vpn_config
end

def pid_file(config)
  destination = config[:destination]
  postfix = config[:vpn_config] == destination ? ".#{destination}" : ''
  format(PID_FILE, postfix: postfix)
end

def pid(config)
  pid_file = pid_file(config)
  return unless pid_file || File.exist?(pid_file)

  File.read(pid_file).strip
end

def runned?(pid)
  return false unless pid

  Process.getpgid(pid)
  true
rescue Errno::ESRCH
  false
end

def start(config)
  exec format(START_COMMAND, bin: config[:bin], vpn_config: config[:vpn_config], pid_file: pid_file(config))
end

def stop(config)
  pid = pid(config)
  return unless runned?(pid)

  `sudo kill #{pid}`
  `sudo rm #{pid_file(config)}`
end

def restart(config)
  stop(config)
  start(config)
end

def status(config)
  puts runned?(pid(config)) ? MESSAGES[:running] : MESSAGES[:not_running]
end

options = parse_options!.tap { |parsed_options| validate_options!(parsed_options) }
config = parse_config(options).tap { |parsed_config| validate_config!(parsed_config) }
send(config[:command], config)
